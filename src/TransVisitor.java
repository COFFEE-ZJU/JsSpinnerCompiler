/*** * Excerpted from "The Definitive ANTLR 4 Reference", * published by The Pragmatic Bookshelf. * Copyrights apply to this code. It may not be used to create training material,  * courses, books, articles, and the like. Contact us if you are in doubt. * We make no guarantees that this code is fit for any purpose.  * Visit http://www.pragmaticprogrammer.com/titles/tpantlr2 for more book information.***/import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Set;import com.google.gson.Gson;import com.google.gson.GsonBuilder;public class TransVisitor extends JaqlSampleBaseVisitor<Integer> {    /** "memory" for our calculator; variable/value pairs go here */	public List<JsonQueryTree> resultTrees = new ArrayList<JsonQueryTree>();		private boolean haveRename;	private String renameId;    private String groupKeyVar = null;    private Constants.OperationType currentOp = Constants.OperationType.NULL;    private Map<String, Constants.DataType> idTypeMap = new HashMap<String, Constants.DataType>();    private Map<String, JsonQueryTree> idValueMap = new HashMap<String, JsonQueryTree>();    private Map<String, JsonSchema> idSchemaMap = new HashMap<String, JsonSchema>();    private JsonQueryTree currentTree = null;    private JsonSchema currentSchema = null;    private JsonSchema prevSchema = null;    private List<JsonProjection> projectionIds = new ArrayList<JsonProjection>();    private Set<String> dupCheck = new HashSet<String>();    private JsonExpression groupByAttrExpr = null;    private JsonExpression aggrAttrExpr = null;    private JsonExpression joinLeftAttrExpr = null;    private JsonExpression joinRightAttrExpr = null;        private String[] joinId = new String[2];    private String[] joinIdRename = new String[2];    private JsonSchema[] joinSchema = new JsonSchema[2];        private void init(){    	haveRename = false;    	renameId = null;    	groupKeyVar = null;    	currentOp = Constants.OperationType.NULL;    	//idTypeMap.clear();    	//idValueMap.clear();    	currentTree = null;    	currentSchema = null;    	prevSchema = null;    	joinId[0] = joinId[1] = null;    	joinIdRename[0] = joinIdRename[1] = null;    	joinSchema[0] = joinSchema[1] = null;    	groupByAttrExpr = null;    	aggrAttrExpr = null;    	joinLeftAttrExpr = null;    	joinRightAttrExpr = null;    	projectionIds.clear();    	dupCheck.clear();    }        @Override    public Integer visitAssignView(JaqlSampleParser.AssignViewContext ctx) {    	String idName = ctx.identifier().getText();    	if(ctx.pipe() != null) visit(ctx.pipe());    	else visit(ctx.join());    	if(currentTree == null) throw new SemanticErrorException("wrong in assignView: currentTree empty!!!");    	if(currentTree.type.equals(Constants.ISTREAM) ||     			currentTree.type.equals(Constants.DSTREAM) ||     			currentTree.type.equals(Constants.RSTREAM)){    		idTypeMap.put(idName, Constants.DataType.STREAM);    	}    	else idTypeMap.put(idName, Constants.DataType.RELATION);    	    	idValueMap.put(idName, currentTree);    	idSchemaMap.put(idName, currentSchema);    	return 0;    }        @Override    public Integer visitReadStream(JaqlSampleParser.ReadStreamContext ctx) {     	String idName = ctx.identifier().getText();    	JsonQueryTree tmpTree = new JsonQueryTree();    	tmpTree.type = "leaf";    	tmpTree.stream_source = ctx.STRING().getText().replaceAll("\"", "");    	if(ctx.FALSE() != null) tmpTree.is_master = false;    	else tmpTree.is_master = true;    	//System.out.println("put id:" + idName);    	idTypeMap.put(idName, Constants.DataType.STREAM);    	idValueMap.put(idName, tmpTree);    	idSchemaMap.put(idName, JsonSchema.getSchema(tmpTree.stream_source));    	return 0;    }    //    @Override //    public Integer visitSetMaster(JaqlSampleParser.SetMasterContext ctx) {//    	String idName = ctx.identifier().getText();//    	if(! idTypeMap.containsKey(idName)) throw new SemanticErrorException("variable "+idName+" undefined");//    	//    	JsonQueryTree tree = idValueMap.get(idName);//    	if(!tree.type.equals("leaf")) throw new SemanticErrorException(idName+" is not leaf stream source");//    	//    	tree.is_master = true;//    	return 0; //    }        @Override     public Integer visitJoin(JaqlSampleParser.JoinContext ctx) {     	currentOp = Constants.OperationType.JOIN;    	if(currentTree != null) throw new SemanticErrorException("currenTree not empty in join");    	currentTree = new JsonQueryTree();    	currentTree.type = "join";    	currentSchema = new JsonSchema();    	if(ctx.joinVar(0).identifier().size() == 2){    		joinIdRename[0] = ctx.joinVar(0).identifier(0).getText();    		joinId[0] = ctx.joinVar(0).identifier(1).getText();    	}    	else{    		joinIdRename[0] = null;    		joinId[0] = ctx.joinVar(0).identifier(0).getText();    	}    	    	if(ctx.joinVar(1).identifier().size() == 2){    		joinIdRename[1] = ctx.joinVar(1).identifier(0).getText();    		joinId[1] = ctx.joinVar(1).identifier(1).getText();    	}    	else{    		joinIdRename[1] = null;    		joinId[1] = ctx.joinVar(1).identifier(0).getText();    	}    	    	if(! idTypeMap.containsKey(joinId[0])) throw new SemanticErrorException("variable "+joinId[0]+" undefined");    	if(! idTypeMap.containsKey(joinId[1])) throw new SemanticErrorException("variable "+joinId[1]+" undefined");    	if(idTypeMap.get(joinId[0]) != Constants.DataType.RELATION ||     			idTypeMap.get(joinId[1]) != Constants.DataType.RELATION){    		throw new SemanticErrorException("join input type wrong, expecting relation type");    	}    	joinSchema[0] = idSchemaMap.get(joinId[0]);    	joinSchema[1] = idSchemaMap.get(joinId[1]);    	currentTree.left_input = idValueMap.get(joinId[0]);    	currentTree.right_input = idValueMap.get(joinId[1]);    	    	visitChildren(ctx);				return 0;    }        @Override     public Integer visitJoinOutVar(JaqlSampleParser.JoinOutVarContext ctx) {     	if(currentTree.join_projection_set == null)    		currentTree.join_projection_set = new ArrayList<JsonJoinProjection>();    	    	JsonJoinProjection proj = new JsonJoinProjection();    	if(ctx.identifier() == null) proj.need_rename = false;    	else {    		proj.need_rename = true;    		proj.rename = ctx.identifier().getText();    	}    	int pos = checkJoinId(ctx.varID().identifier(0).getText());    	JsonExpression expr = new ExprVisitor(true, ctx.varID().identifier(0).getText(), joinSchema[pos]).visit(ctx.varID());    	proj.attribute_name = expr.id_name;    	String lastName = proj.attribute_name.get(proj.attribute_name.size()-1);    	    	if(proj.need_rename) checkDuplication(proj.rename);    	else checkDuplication(lastName);    	    	switch (pos) {		case 0:			proj.attribute_source = "left";			break;		case 1:			proj.attribute_source = "right";			break;		default:			break;		}    	    	currentTree.join_projection_set.add(proj);    	String tmpString;    	if(proj.need_rename) tmpString = proj.rename;    	else tmpString = lastName;    	    	currentSchema.nameToType.put(tmpString, expr.retType);    	if(expr.arrayDataType != null) currentSchema.arrayNameToType.put(tmpString, expr.arrayDataType);    	if(expr.objectSchema != null) currentSchema.objectNameToSchema.put(tmpString, expr.objectSchema);    	return 0;     }        @Override     public Integer visitVarID(JaqlSampleParser.VarIDContext ctx) {    	if(currentTree.left_join_attribute == null || currentTree.right_join_attribute == null){	    	int idPos = checkJoinId(ctx.identifier(0).getText());	    	if(idPos == 0){	    		if(currentTree.left_join_attribute != null)	    			throw new SemanticErrorException("duplicated relation attribute");	    			    		JsonExpression expr = new ExprVisitor(true, ctx.identifier(0).getText(), joinSchema[0]).visit(ctx);	    		currentTree.left_join_attribute = expr.id_name;	    		joinLeftAttrExpr = expr;	    	}			else{	    		if(currentTree.right_join_attribute != null)	    			throw new SemanticErrorException("duplicated relation attribute");	    			    		JsonExpression expr = new ExprVisitor(true, ctx.identifier(0).getText(), joinSchema[1]).visit(ctx);				currentTree.right_join_attribute = expr.id_name;				joinRightAttrExpr = expr;			}    	}    	else{    		throw new SemanticErrorException("Something wrong in VarID!");    	}    	if(currentTree.left_join_attribute != null && currentTree.right_join_attribute != null){    		if((joinLeftAttrExpr.retType != Constants.JsonValueType.INTEGER && joinLeftAttrExpr.retType != Constants.JsonValueType.NUMBER) ||    			(joinRightAttrExpr.retType != Constants.JsonValueType.INTEGER && joinRightAttrExpr.retType != Constants.JsonValueType.NUMBER)){    			if(joinLeftAttrExpr.retType != joinRightAttrExpr.retType)    				throw new SemanticErrorException("attribute type mismatch");    		}    	}    	    	return 0;    }        @Override     public Integer visitTransExprVar(JaqlSampleParser.TransExprVarContext ctx) {     	    	if(ctx.var() != null) visit(ctx.var());    	else{    		JsonProjection tmp = new JsonProjection();    		tmp.need_rename = true;    		tmp.rename = ctx.identifier().getText();    		tmp.expression = new ExprVisitor(haveRename, renameId, prevSchema).visit(ctx.exprs());    		checkDuplication(tmp.rename);    		currentTree.projection_attibute_set.add(tmp);    		currentSchema.nameToType.put(tmp.rename, tmp.expression.retType);    		if(tmp.expression.arrayDataType != null) currentSchema.arrayNameToType.put(tmp.rename, tmp.expression.arrayDataType);        	if(tmp.expression.objectSchema != null) currentSchema.objectNameToSchema.put(tmp.rename, tmp.expression.objectSchema);    	}    	return 0;     }    @Override     public Integer visitVar(JaqlSampleParser.VarContext ctx) throws SemanticErrorException {     	JsonExpression expr = new ExprVisitor(haveRename, renameId, prevSchema).visit(ctx);    	    	switch (currentOp) {		case TRANS:			String lastId = expr.id_name.get(expr.id_name.size()-1);			checkDuplication(lastId);			currentTree.projection_attibute_set.add(new JsonProjection(expr.id_name));			currentSchema.nameToType.put(lastId, expr.retType);			if(expr.arrayDataType != null) currentSchema.arrayNameToType.put(lastId, expr.arrayDataType);	    	if(expr.objectSchema != null) currentSchema.objectNameToSchema.put(lastId, expr.objectSchema);			break;		case GROUP:			currentTree.groupby_attribute_names = expr.id_name;			groupByAttrExpr = expr;			break;		default:			break;		}    	return 0;     }    /** ID '=' expr NEWLINE */    @Override    public Integer visitStat(JaqlSampleParser.StatContext ctx){    	init();    	    	try {    		visitChildren(ctx);        	        	Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();        	if(ctx.identifier() != null){        		String id = ctx.identifier().getText();        		if(! idTypeMap.containsKey(id)){        			throw new SemanticErrorException("variale not found");        		}        		currentTree = idValueMap.get(id);        	}        	        	//System.out.println(currentSchema);        	        	if(ctx.assignView() != null || ctx.readStream() != null) return 0;        	if(currentTree != null){        		JsonQueryTree tmp = new JsonQueryTree();        		tmp.type = "root";        		tmp.input = currentTree;        		//System.out.println(gson.toJson(tmp));        		resultTrees.add(tmp);        	}        			} catch (SemanticErrorException e) {			System.err.println(e.getMessage());			e.printStackTrace();		}    	    	return 0;    }        @Override     public Integer visitPipe(JaqlSampleParser.PipeContext ctx) {    	if(currentTree != null) throw new SemanticErrorException("currenTree not empty in pipe");    	String idName = ctx.identifier().getText();    	    	//System.out.println("check id:" + idName);    	if(! idTypeMap.containsKey(idName)){    		throw new SemanticErrorException("variable "+idName+" undefined");    	}    	    	currentTree = idValueMap.get(idName);    	currentSchema = idSchemaMap.get(idName);    	    	for(int i=0;i<ctx.pipeExpr().size();i++){    		prevSchema = currentSchema;    		currentSchema = null;    		visit(ctx.pipeExpr(i));    	}    	return 0;    }        @Override    public Integer visitGroupSingleLabel(JaqlSampleParser.GroupSingleLabelContext ctx) {    	currentOp = Constants.OperationType.GROUP;    	if(ctx.gby == null)     		throw new SemanticErrorException("currently we do not support group w/o \"by\"");    	if(isStream(currentTree)){    		throw new SemanticErrorException("wrong input type: expecting relation type");    	}    	JsonQueryTree tmp = new JsonQueryTree();    	tmp.type = "groupby_aggregation";    	tmp.input = currentTree;    	currentTree = tmp;    	currentSchema = new JsonSchema();    	    	int startPos = 0;    	if(ctx.geach != null){    		haveRename = true;    		renameId = ctx.identifier(0).getText();    		startPos ++;    	}    	else {    		haveRename = false;    	}    	groupKeyVar = ctx.identifier(startPos).getText();		visit(ctx.var());				haveRename = false;		if(ctx.gas != null){			haveRename = true;			renameId = ctx.identifier(startPos+1).getText();		}		else {			haveRename = false;		}		visit(ctx.aggrExprs()); 				JsonQueryTree projTree = new JsonQueryTree();		projTree.type = "projection";		projTree.projection_attibute_set = new ArrayList<JsonProjection>(projectionIds);		projTree.input = currentTree;		currentTree = projTree;		    	return 0;    }        @Override     public Integer visitAggrExpr(JaqlSampleParser.AggrExprContext ctx) {    	if(ctx.aggrFunc() == null){    		String tmpString;    		if(ctx.identifier().size() == 1){	    		if(! ctx.identifier(0).getText().equals(groupKeyVar)) 	    			throw new SemanticErrorException("variable "+ctx.identifier(0).getText()+" undefined");	    		else{	    			checkDuplication(groupKeyVar);	    			projectionIds.add(new JsonProjection(currentTree.groupby_attribute_names,groupKeyVar));	    			tmpString = groupKeyVar;	    		}    		}    		else{    			if(! ctx.identifier(1).getText().equals(groupKeyVar)) 	    			throw new SemanticErrorException("variable "+ctx.identifier(1).getText()+" undefined");	    		else{	    			checkDuplication(ctx.identifier(0).getText());	    			projectionIds.add(	    					new JsonProjection(currentTree.groupby_attribute_names, ctx.identifier(0).getText())	    					);	    			tmpString = ctx.identifier(0).getText();	    		}    		}    		    		currentSchema.nameToType.put(tmpString, groupByAttrExpr.retType);			if(groupByAttrExpr.arrayDataType != null) currentSchema.arrayNameToType.put(tmpString, groupByAttrExpr.arrayDataType);        	if(groupByAttrExpr.objectSchema != null) currentSchema.objectNameToSchema.put(tmpString, groupByAttrExpr.objectSchema);    	}    	else{    		List<String> tmpList = new ArrayList<String>();    		tmpList.add(ctx.identifier(0).getText());    		projectionIds.add(new JsonProjection(tmpList));    		if(currentTree.result_attribute_name != null){        		JsonQueryTree tmp = new JsonQueryTree();        		tmp.groupby_attribute_names = new ArrayList<String>(currentTree.groupby_attribute_names);        		tmp.type = currentTree.type;        		tmp.input = currentTree;        		currentTree = tmp;        	}    		currentTree.result_attribute_name = ctx.identifier(0).getText();    		visit(ctx.aggrFunc());    		    		if(currentTree.aggregate_operation.equals("count"))    			currentSchema.nameToType.put(currentTree.result_attribute_name, Constants.JsonValueType.INTEGER);    		else{    			currentSchema.nameToType.put(currentTree.result_attribute_name, aggrAttrExpr.retType);    			if(aggrAttrExpr.arrayDataType != null) currentSchema.arrayNameToType.put(currentTree.result_attribute_name, aggrAttrExpr.arrayDataType);            	if(aggrAttrExpr.objectSchema != null) currentSchema.objectNameToSchema.put(currentTree.result_attribute_name, aggrAttrExpr.objectSchema);    		}    	}    	    	return 0;     }        @Override     public Integer visitAggrFunc(JaqlSampleParser.AggrFuncContext ctx) {    	List<String> tmpList = new ArrayList<String>();    	int i;    	if(ctx.dollar==null){    		i = 1;    		if(! haveRename || !renameId.equals(ctx.identifier(0).getText()))    			throw new SemanticErrorException("variable "+ctx.identifier(0).getText()+" undefined");    	}    	else{    		i = 0;    		if(haveRename)    			throw new SemanticErrorException("variable $ undefined");    	}    	    	JsonSchema tmpSch = prevSchema;		String tmpString;    	for(;i<ctx.identifier().size()-1;i++){    		tmpString = ctx.identifier(i).getText();    		tmpList.add(tmpString);    		checkAttrContaining(tmpSch, tmpString);    		if(tmpSch.nameToType.get(tmpString) != Constants.JsonValueType.OBJECT)				throw new SemanticErrorException("attribute "+tmpString+" is not an object type");			tmpSch = tmpSch.objectNameToSchema.get(tmpString);    	}    	tmpString = ctx.identifier(i).getText();    	tmpList.add(tmpString);    	checkAttrContaining(tmpSch, tmpString);    	aggrAttrExpr = new JsonExpression();    	aggrAttrExpr.type = "id";    	aggrAttrExpr.id_name = tmpList;    	aggrAttrExpr.retType = tmpSch.nameToType.get(tmpString);    	if(aggrAttrExpr.retType == Constants.JsonValueType.ARRAY){    		aggrAttrExpr.arrayDataType = tmpSch.arrayNameToType.get(tmpString);    		if(aggrAttrExpr.arrayDataType == Constants.JsonValueType.OBJECT)    			aggrAttrExpr.objectSchema = tmpSch.objectNameToSchema.get(tmpString);    	}    	currentTree.aggregation_attribute_name = tmpList;    	    	switch (ctx.aggrFuncName().getText()) {		case "sum":			currentTree.aggregate_operation = "sum";			break;		case "avg":			currentTree.aggregate_operation = "average";			break;		case "count":			currentTree.aggregate_operation = "count";			break;		case "min":			currentTree.aggregate_operation = "min";			throw new SemanticErrorException("aggrFunc \"min\"currently not supported");		case "max":			currentTree.aggregate_operation = "max";			throw new SemanticErrorException("aggrFunc \"max\"currently not supported");		default:			break;		}    	    	if(currentTree.aggregate_operation.equals("sum") || currentTree.aggregate_operation.equals("average")){    		if(aggrAttrExpr.retType != Constants.JsonValueType.INTEGER && aggrAttrExpr.retType != Constants.JsonValueType.NUMBER)    			throw new SemanticErrorException("aggregation of type: "+aggrAttrExpr.retType+"not supported");    	}    	    	return 0;     }        @Override    public Integer visitFilterLabel(JaqlSampleParser.FilterLabelContext ctx) {    	currentOp = Constants.OperationType.FILTER;    	if(isStream(currentTree)){    		throw new SemanticErrorException("wrong input type: expecting relation type");    	}    	JsonQueryTree tmp = new JsonQueryTree();    	tmp.type = "selection";    	tmp.input = currentTree;    	currentTree = tmp;    	currentSchema = new JsonSchema(prevSchema);    	        haveRename = false;        if(ctx.identifier() != null){        	haveRename = true;        	renameId = ctx.identifier().getText();        }                currentTree.selection_condition = new CondVisitor(haveRename, renameId, prevSchema).visit(ctx);                return 0;    }        @Override    public Integer visitTransformLabel(JaqlSampleParser.TransformLabelContext ctx) {     	currentOp = Constants.OperationType.TRANS;    	if(isStream(currentTree)){    		throw new SemanticErrorException("wrong input type: expecting relation type");    	}    	JsonQueryTree tmp = new JsonQueryTree();    	tmp.type = "projection";    	tmp.input = currentTree;    	tmp.projection_attibute_set = new ArrayList<JsonProjection>();    	currentTree = tmp;    	currentSchema = new JsonSchema();    	    	haveRename = false;    	if(ctx.identifier() != null){    		haveRename = true;    		renameId = ctx.identifier().getText();    	}    	    	return visitChildren(ctx);    }        @Override    public Integer visitStreamLabel(JaqlSampleParser.StreamLabelContext ctx) {     	currentOp = Constants.OperationType.STREAM;    	if(isStream(currentTree)){    		throw new SemanticErrorException("wrong input type: expecting relation type");    	}    	JsonQueryTree tmp = new JsonQueryTree();    	tmp.type = ctx.stream().getText();    	tmp.input = currentTree;    	currentTree = tmp;    	currentSchema = new JsonSchema(prevSchema);    	return 0;    }        @Override     public Integer visitWindowLabel(JaqlSampleParser.WindowLabelContext ctx) {    	currentOp = Constants.OperationType.WINDOW;    	if(! isStream(currentTree)){    		throw new SemanticErrorException("wrong input type: expecting stream type");    	}    	JsonQueryTree tmp = new JsonQueryTree();    	tmp.input = currentTree;    	currentTree = tmp;    	currentSchema = new JsonSchema(prevSchema);    	    	return visit(ctx.windowRange());    	    }        @Override     public Integer visitWindowTimeLabel(JaqlSampleParser.WindowTimeLabelContext ctx) {    	currentTree.type = "rangewindow";    	    	if(ctx.INT() == null){    		switch (ctx.timeRange().getText()) {			case "unbounded":				currentTree.windowsize = "unbounded";				break;			case "now":				currentTree.windowsize = "now";				break;			default:				break;			}    		    	}    	else{    		int timeQuan = Integer.parseInt(ctx.INT().getText());    		String timeUnit = ctx.timeUnit().getText();    		    		currentTree.windowsize = timeQuan + " " + timeUnit;    	}    	    	return 0;    	    }        @Override     public Integer visitWindowRowLabel(JaqlSampleParser.WindowRowLabelContext ctx) {    	currentTree.type = "rowwindow";    	    	if(ctx.INT() == null) currentTree.windowsize = "unbounded";    	else{    		int size = Integer.parseInt(ctx.INT().getText());    		currentTree.windowsize = ""+size;    	}    	    	return 0;    	    }        @Override     public Integer visitWindowPartitionLabel(JaqlSampleParser.WindowPartitionLabelContext ctx) {    	currentTree.type = "partitionwindow";    	throw new SemanticErrorException(" partition window not supported yet");    	    	//return 0;    }        private int checkJoinId(String id){    	boolean res0,res1;    	if(joinIdRename[0]!=null) res0 = id.equals(joinIdRename[0]);    	else res0 = id.equals(joinId[0]);    	    	if(joinIdRename[1]!=null) res1 = id.equals(joinIdRename[1]);    	else res1 = id.equals(joinId[1]);    	    	if(res0 && !res1) return 0;    	else if(!res0 && res1) return 1;    	else if(!res0 && !res1) throw new SemanticErrorException("variable "+id+" undefined");    	else throw new SemanticErrorException("duplicated id names");    }        private boolean isStream(JsonQueryTree tree){    	if(tree.type == null){    		System.err.println("empty tree");    		return false;    	}    	if(tree.type.equals("leaf")||tree.type.contains("stream")) return true;    	else return false;    	    }        private void checkDuplication(String id){    	if(dupCheck.contains(id))    		throw new SemanticErrorException("variable "+id+" duplicated");    	else dupCheck.add(id);    }        private void checkAttrContaining(JsonSchema schema, String attrName){    	if(! schema.nameToType.containsKey(attrName))    		throw new SemanticErrorException("attribute name "+attrName+" is not valid.");    }}